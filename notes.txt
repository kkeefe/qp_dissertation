##############
Detector Notes
##############

Geiger Counters

proportional counters

bubble chambers

spark chambers

multiwire proportional counter

time projection chamber

LArTPC

QPix

T2K
t2k is (Tokai to Kamioka) is a long-baseline neutrino experiment, over 295 km
long baseline neutrino oscillation experiment
Wants to measure dM23 and theta23
Uses proton beam created at J-parc
295 km baseline
main goal is to measure theta13 by observing ve appearance from vu disappearance.
uses 0.6 GeV beam
%% nd is at j-parc, far detector is at superk

% Double Chooz used two identical gadolinium-doped liquid scintillator detectors

NOvA (previous generation such as MINOS / MINERvA)
liquid scintillator, oscillator from Fermilab
Far detector in Minnesota uses liquid scintillator as its target
810 km baseline
Measures NuMI (Neutrinos at main injector) beam
muon neutrinos come from pion decay

beam is governed by pion decays.
electron decay is the second most common, but is surpressed by an effect known as helicity supression.
Re ~ 1.3 x10^-4


Daya Bay
Measured theta12 to be non-zero by >5 sigma


##############
Neutrino Notes:
##############

Mikheyev-Smirnov-Wolfenstein (MSW) effect [45, 46] can be used to determine the mass ordering

BooNE : Booster Neutrino Experiment, MiniBooNE (cherenkov), MicroBooNE (liquid argon), both at fermilab
CC-QE : Stands for charge-current quasi-elastic. neutrino-nucleus scattering events, originated from miniBooNE
Liquid Scintillator Neutrino Detector (LSND) was a scintillation counter at Los Alamos National Laboratory that measured the number of neutrinos being produced by an accelerator neutrino source

https://neutrinos.fnal.gov/history/

##############
General Notes:
##############

- Why not needed: cocotb
-- by its own definition: "cocotb is a COroutine based COsimulation TestBench environment for verifying VHDL and SystemVerilog RTL using Python".
-- therefore, its purpose is to verify hdl, not motivate hdl design (the purpose of this work).
-- these simulations constrain the hardware requirements of a digital node, the discussions motivate a basis for what the FSM which governs the digital node should be.

## D2 code for images @ https://play.d2lang.com/
 Simulation Stepping Procedure: {
   shape: sequence_diagram
   direction: right
   Time: Time
   Hit\nContainer: Hit\nContainer
   Local\nFIFO: Local\nFIFO
   Simulation Start: {
     Time.a -> Hit\nContainer.a: Inject Reset(s)\n@ Time: Tr
   }
   Update by Time Step: {
     Time -> Time: +Timestep
   }
   Time greater than Injected Hit: {
     Time.b -> Hit\nContainer.b: Time>=Tr
     Hit\nContainer.b -> Local\nFIFO: Write FIFO
   }
   Update Time by Transaction Time: {
     Local\nFIFO -> Time.d: +Transaction Time
   }
   Repeat: {
     Time -> Time: +Timestep
   }
 }



Simulation: Process {
  Tile: Tile {
    Nodes: {
      shape: stored_data
      style.multiple: true
    }
  }

  Procedure: Packet Queue {
    Transactions: {
      shape: queue
      style.multiple: true
    }
  }

  Next Transaction: {
    shape: queue
    Time: Complete\nTime {
      shape: square
    }
    Node: {
      shape: stored_data
    }
    Packet: {
      shape: square
    }
  }

  New Transactions: {
    shape: queue
    style.multiple: true
  }

  Tile.Nodes -> Tile.Nodes: Read Injected Hit
  Tile.Nodes -> Procedure: Push Packets {source-arrowhead.label: 4}

  Procedure -> Next Transaction: Soonest Transaction {source-arrowhead.label: 1}
  Next Transaction.packet -> Next Transaction.node: Receive Byte
  Next Transaction.time -> Next Transaction.node: Byte Arrival Time
  Next Transaction.Node -> New Transactions: Response Packets {source-arrowhead.label: 2}
  New Transactions -> Procedure: Response Packets {source-arrowhead.label: 3}
}
